# 《深入剖析 Kubernetes》学习笔记 Day 2

今天学习了容器技术概念入门篇 (5讲)的前3讲，白话容器基础。

**前文回顾**

* 容器技术的兴起源于 PaaS 技术的普及；
* Docker 公司发布的 Docker 项目具有里程碑式的意义；
* Docker 项目通过“容器镜像”，解决了应用打包这个根本性难题。
* 容器本身没有价值，有价值的是「容器编排」，Kubernetes 项目和 CNCF 社区胜出。

**从进程说开去**

容器作为沙盒的作用：

1. 应用与应用之间，就因为有了边界而不至于相互干扰。
2. 应用可以被方便地搬来搬去

进程，就是一个程序运行起来后的计算机执行环境的总和。包括内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息。

容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个「边界」。

容器的本质是一种特殊的进程。

Cgroups 技术是用来制造约束的主要手段，而 Namespace 技术则是用来修改进程视图的主要方法。

用 clone() 系统调用创建一个新进程时，在参数中指定 CLONE_NEWPID，新创建的这个进程将会「看到」一个全新的进程空间，在这个进程空间里，它的 PID 是 1。即 PID Namespace。

Linux 还支持 Mount、UTS、IPC、Network 和 User 等 Namespace。

> 感悟：程序员应该尽量去「复用」，基于已有的技术去解决新的问题，甚至是开拓一项新的技术。不要轻易去造轮子！

**隔离与限制**

使用虚拟化技术作为应用沙盒，就必须要由 Hypervisor 来负责创建虚拟机，这个虚拟机是真实存在的，并且它里面必须运行一个完整的 Guest OS 才能执行用户的应用进程。这带来了额外的资源消耗和占用。

容器单独挂载不同版本的 OS 文件，但共享宿主机内核，这限制了 Guest OS的选择。

很多资源不能被 Namespace 化，比如时间，容器中修改了时间，整个宿主机时间都会随之修改。

Cgroups 全称 Linux Control Group。Google 的工程师在 2006 年发起 Cgroups 这项特性的时候，曾将它命名为「进程容器」（process container）。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。还能够对进程进行优先级设置、审计，以及将进程挂起和恢复等操作。

Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件的方式组织在操作系统的 /sys/fs/cgroup 路径下。诸如 cpuset、cpu、 memory 这样的子目录，也叫子系统。这些都是当前可以被 Cgroups 进行限制的资源种类。

CPU 限制方法例子：
cpu.cfs_quota_us  20000
cpu.cfs_period_us 100000
tasks $PID

限制进程（$PID）在长度为 cfs_period 的一段时间内，只能被分配到总量为 cfs_quota 的 CPU 时间。即在每 100 ms 的时间里，被该控制组限制的进程只能使用 20 ms 的 CPU 时间，也就是 20% 的 CPU 带宽。

Cgroups 子系统还包括 blkio（IO限制）、cpuset（绑核）、memory（内存限制）。

/proc 文件系统不了解 Cgroups 限制的存在，在容器里执行 top 指令，显示是宿主机的 CPU 和内存数据。可以使用 lxcfs 来解决。

> 感悟：程序世界里没有银弹，解决一个问题的同时必然会引入另一个问题或复杂度，架构师要权衡当前最迫切要解决的问题。

**深入理解容器镜像**

Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。

我们可以在容器进程启动之前重新挂载它的整个根目录“/”。而由于 Mount Namespace 的存在，这个挂载对宿主机不可见，所以容器进程就可以在里面随便折腾了。

Mount Namespace 正是基于对 chroot 的不断改良才被发明出来的，它也是 Linux 操作系统里的第一个 Namespace。

一般会在这个容器的根目录下挂载一个完整操作系统的文件系统。而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的「容器镜像」。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。操作系统只有在开机启动时才会加载指定版本的内核镜像。

对 Docker 项目来说，它最核心的原理实际上就是为待创建的用户进程：

1. 启用 Linux Namespace 配置
2. 设置指定的 Cgroups 参数
3. 切换进程的根目录（pivot_root 或 chroot）

有了容器镜像「打包操作系统」的能力，这个最基础的依赖环境也变成了应用沙盒的一部分。这种深入到操作系统级别的运行环境一致性，打通了应用在本地开发和远端执行环境之间难以逾越的鸿沟。

Docker 在镜像的设计中，引入了层（layer）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。其用到了一种叫作联合文件系统（UnionFS）的能力，可以将多个不同位置的目录联合挂载（union mount）到同一个目录下。

容器 rootfs 的组成：

1. 只读层。ro+wh，即 readonly+whiteout。whiteout 用于遮挡被删除的文件。
2. 可读写层。rw，即 read write。在没有写入文件之前，这个目录是空的。而一旦在容器里做了写操作，修改产生的内容就会以增量的方式出现在这个层中。修改后用 docker commit 和 push，保存这个被修改过的可读写层，并上传到 Docker Hub 上，供其他人使用。
3. Init 层。专门用来存放 /etc/hosts、/etc/resolv.conf 等启动容器时才需要写入的信息比如 hostname。用户执行 docker commit 只会提交可读写层，不包含Init 层的内容。

> 感悟：「分层镜像」才是 Docker 的精髓所在，是一种牛逼的微创新。我们都应该站在巨人的肩膀上做事情！

学习来源： 极客时间 https://time.geekbang.org/column/intro/100015201?tab=catalog


